// ----------------------
// ðŸ§± PHASE 1: DRIZZLE SCHEMA EXTENSIONS
// ----------------------

import { pgTable, serial, integer, text, boolean, jsonb, timestamp } from 'drizzle-orm/pg-core';

export const quests = pgTable("quests", {
  id: serial("id").primaryKey(),
  campaignId: integer("campaign_id").notNull(),
  title: text("title").notNull(),
  description: text("description").notNull(),
  rewards: jsonb("rewards").default([]),
  status: text("status").notNull().default('available'),
  createdAt: timestamp("created_at").defaultNow()
});

export const items = pgTable("items", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  properties: jsonb("properties").default({}),
  createdAt: timestamp("created_at").defaultNow()
});

export const combatEncounters = pgTable("combat_encounters", {
  id: serial("id").primaryKey(),
  campaignId: integer("campaign_id").notNull(),
  isActive: boolean("is_active").default(true),
  currentTurn: integer("current_turn").default(0),
  createdAt: timestamp("created_at").defaultNow()
});

export const combatEntities = pgTable("combat_entities", {
  id: serial("id").primaryKey(),
  encounterId: integer("encounter_id").notNull(),
  name: text("name").notNull(),
  hp: integer("hp").notNull(),
  maxHp: integer("max_hp").notNull(),
  initiative: integer("initiative").notNull(),
  isPlayer: boolean("is_player").notNull(),
  conditions: text("conditions").array().default([])
});

export const sessionLogs = pgTable("session_logs", {
  id: serial("id").primaryKey(),
  campaignId: integer("campaign_id").notNull(),
  playerAction: text("player_action").notNull(),
  dmNarrative: text("dm_narrative"),
  diceRoll: jsonb("dice_roll"),
  outcome: text("outcome"),
  createdAt: timestamp("created_at").defaultNow()
});

// ----------------------
// ðŸ”„ PHASE 2: EXPRESS COMBAT API
// ----------------------

// Pseudocode outline only:

// POST /api/combat/start
// Starts a new combat encounter with a list of entities
// PATCH /api/combat/next-turn
// Advances turn in the encounter
// PATCH /api/combat/apply-damage
// Applies HP changes and updates conditions
// GET /api/combat/:id/status
// Returns full encounter + entity state

// These will call Drizzle to interact with combatEncounters and combatEntities

// ----------------------
// ðŸ§  PHASE 3: MODULAR AI PROMPTS
// ----------------------

function getCombatPrompt(context: DMContext): string {
  return `=== COMBAT DETECTED ===\nInitiative Order: ${context.initiativeOrder.join(", ")}\nCurrent Turn: ${context.currentTurn}\nHP: ${context.characters.map(c => `${c.name}: ${c.hp}/${c.maxHp}`).join(", ")}\nConditions: ${context.characters.map(c => `${c.name}: ${c.conditions?.join(" ") || "None"}`).join(", ")}`;
}

function getNarrativePrompt(context: DMContext): string {
  return `Current scene at ${context.location}:\n${context.narrative}`;
}

function buildPrompt(context: DMContext): string {
  const base = `You are a Dungeon Master continuing a high-fantasy RPG adventure.`;
  const scene = context.sceneType === 'combat' ? getCombatPrompt(context) : getNarrativePrompt(context);
  const history = context.sessionHistory?.slice(-5).join("\n") || '';
  return `${base}\n\n${scene}\n\nRecent history:\n${history}\n\nPlayer action: \"${context.lastAction}\"`;
}

// ----------------------
// ðŸ“ PHASE 4: SESSION LOG PERSISTENCE
// ----------------------

// Example Express route for AI call
app.post('/api/openai/generate-story', async (req, res) => {
  const { campaignId, prompt } = req.body;
  const aiResponse = await callOpenAIWithPrompt(prompt); // your GPT call

  await db.insert(sessionLogs).values({
    campaignId,
    playerAction: prompt,
    dmNarrative: aiResponse.narrative,
    diceRoll: aiResponse.diceRoll || null,
    outcome: aiResponse.outcome || '',
  });

  res.json(aiResponse);
});
